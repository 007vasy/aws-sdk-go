// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.

// Package kms provides a client for AWS Key Management Service.
package kms

import (
	"time"

	"github.com/awslabs/aws-sdk-go/aws"
)

// CreateAliasRequest generates a request for the CreateAlias operation.
func (c *KMS) CreateAliasRequest(input *CreateAliasInput) (req *aws.Request, output *CreateAliasOutput) {
	if opCreateAlias == nil {
		opCreateAlias = &aws.Operation{
			Name:       "CreateAlias",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	req = aws.NewRequest(c.Service, opCreateAlias, input, output)
	output = &CreateAliasOutput{}
	req.Data = output
	return
}

// Creates a display name for a customer master key. An alias can be used to
// identify a key and should be unique. The console enforces a one-to-one mapping
// between the alias and a key. An alias name can contain only alphanumeric
// characters, forward slashes (/), underscores (_), and dashes (-).
func (c *KMS) CreateAlias(input *CreateAliasInput) (output *CreateAliasOutput, err error) {
	req, out := c.CreateAliasRequest(input)
	output = out
	err = req.Send()
	return
}

var opCreateAlias *aws.Operation

// CreateGrantRequest generates a request for the CreateGrant operation.
func (c *KMS) CreateGrantRequest(input *CreateGrantInput) (req *aws.Request, output *CreateGrantOutput) {
	if opCreateGrant == nil {
		opCreateGrant = &aws.Operation{
			Name:       "CreateGrant",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	req = aws.NewRequest(c.Service, opCreateGrant, input, output)
	output = &CreateGrantOutput{}
	req.Data = output
	return
}

// Adds a grant to a key to specify who can access the key and under what conditions.
// Grants are alternate permission mechanisms to key policies. If absent, access
// to the key is evaluated based on IAM policies attached to the user. By default,
// grants do not expire. Grants can be listed, retired, or revoked as indicated
// by the following APIs. Typically, when you are finished using a grant, you
// retire it. When you want to end a grant immediately, revoke it. For more
// information about grants, see Grants (http://docs.aws.amazon.com/kms/latest/developerguide/grants.html).
//  ListGrants RetireGrant RevokeGrant
func (c *KMS) CreateGrant(input *CreateGrantInput) (output *CreateGrantOutput, err error) {
	req, out := c.CreateGrantRequest(input)
	output = out
	err = req.Send()
	return
}

var opCreateGrant *aws.Operation

// CreateKeyRequest generates a request for the CreateKey operation.
func (c *KMS) CreateKeyRequest(input *CreateKeyInput) (req *aws.Request, output *CreateKeyOutput) {
	if opCreateKey == nil {
		opCreateKey = &aws.Operation{
			Name:       "CreateKey",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	req = aws.NewRequest(c.Service, opCreateKey, input, output)
	output = &CreateKeyOutput{}
	req.Data = output
	return
}

// Creates a customer master key. Customer master keys can be used to encrypt
// small amounts of data (less than 4K) directly, but they are most commonly
// used to encrypt or envelope data keys that are then used to encrypt customer
// data. For more information about data keys, see GenerateDataKey and GenerateDataKeyWithoutPlaintext.
func (c *KMS) CreateKey(input *CreateKeyInput) (output *CreateKeyOutput, err error) {
	req, out := c.CreateKeyRequest(input)
	output = out
	err = req.Send()
	return
}

var opCreateKey *aws.Operation

// DecryptRequest generates a request for the Decrypt operation.
func (c *KMS) DecryptRequest(input *DecryptInput) (req *aws.Request, output *DecryptOutput) {
	if opDecrypt == nil {
		opDecrypt = &aws.Operation{
			Name:       "Decrypt",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	req = aws.NewRequest(c.Service, opDecrypt, input, output)
	output = &DecryptOutput{}
	req.Data = output
	return
}

// Decrypts ciphertext. Ciphertext is plaintext that has been previously encrypted
// by using the Encrypt function.
func (c *KMS) Decrypt(input *DecryptInput) (output *DecryptOutput, err error) {
	req, out := c.DecryptRequest(input)
	output = out
	err = req.Send()
	return
}

var opDecrypt *aws.Operation

// DeleteAliasRequest generates a request for the DeleteAlias operation.
func (c *KMS) DeleteAliasRequest(input *DeleteAliasInput) (req *aws.Request, output *DeleteAliasOutput) {
	if opDeleteAlias == nil {
		opDeleteAlias = &aws.Operation{
			Name:       "DeleteAlias",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	req = aws.NewRequest(c.Service, opDeleteAlias, input, output)
	output = &DeleteAliasOutput{}
	req.Data = output
	return
}

// Deletes the specified alias.
func (c *KMS) DeleteAlias(input *DeleteAliasInput) (output *DeleteAliasOutput, err error) {
	req, out := c.DeleteAliasRequest(input)
	output = out
	err = req.Send()
	return
}

var opDeleteAlias *aws.Operation

// DescribeKeyRequest generates a request for the DescribeKey operation.
func (c *KMS) DescribeKeyRequest(input *DescribeKeyInput) (req *aws.Request, output *DescribeKeyOutput) {
	if opDescribeKey == nil {
		opDescribeKey = &aws.Operation{
			Name:       "DescribeKey",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	req = aws.NewRequest(c.Service, opDescribeKey, input, output)
	output = &DescribeKeyOutput{}
	req.Data = output
	return
}

// Provides detailed information about the specified customer master key.
func (c *KMS) DescribeKey(input *DescribeKeyInput) (output *DescribeKeyOutput, err error) {
	req, out := c.DescribeKeyRequest(input)
	output = out
	err = req.Send()
	return
}

var opDescribeKey *aws.Operation

// DisableKeyRequest generates a request for the DisableKey operation.
func (c *KMS) DisableKeyRequest(input *DisableKeyInput) (req *aws.Request, output *DisableKeyOutput) {
	if opDisableKey == nil {
		opDisableKey = &aws.Operation{
			Name:       "DisableKey",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	req = aws.NewRequest(c.Service, opDisableKey, input, output)
	output = &DisableKeyOutput{}
	req.Data = output
	return
}

// Marks a key as disabled, thereby preventing its use.
func (c *KMS) DisableKey(input *DisableKeyInput) (output *DisableKeyOutput, err error) {
	req, out := c.DisableKeyRequest(input)
	output = out
	err = req.Send()
	return
}

var opDisableKey *aws.Operation

// DisableKeyRotationRequest generates a request for the DisableKeyRotation operation.
func (c *KMS) DisableKeyRotationRequest(input *DisableKeyRotationInput) (req *aws.Request, output *DisableKeyRotationOutput) {
	if opDisableKeyRotation == nil {
		opDisableKeyRotation = &aws.Operation{
			Name:       "DisableKeyRotation",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	req = aws.NewRequest(c.Service, opDisableKeyRotation, input, output)
	output = &DisableKeyRotationOutput{}
	req.Data = output
	return
}

// Disables rotation of the specified key.
func (c *KMS) DisableKeyRotation(input *DisableKeyRotationInput) (output *DisableKeyRotationOutput, err error) {
	req, out := c.DisableKeyRotationRequest(input)
	output = out
	err = req.Send()
	return
}

var opDisableKeyRotation *aws.Operation

// EnableKeyRequest generates a request for the EnableKey operation.
func (c *KMS) EnableKeyRequest(input *EnableKeyInput) (req *aws.Request, output *EnableKeyOutput) {
	if opEnableKey == nil {
		opEnableKey = &aws.Operation{
			Name:       "EnableKey",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	req = aws.NewRequest(c.Service, opEnableKey, input, output)
	output = &EnableKeyOutput{}
	req.Data = output
	return
}

// Marks a key as enabled, thereby permitting its use. You can have up to 25
// enabled keys at one time.
func (c *KMS) EnableKey(input *EnableKeyInput) (output *EnableKeyOutput, err error) {
	req, out := c.EnableKeyRequest(input)
	output = out
	err = req.Send()
	return
}

var opEnableKey *aws.Operation

// EnableKeyRotationRequest generates a request for the EnableKeyRotation operation.
func (c *KMS) EnableKeyRotationRequest(input *EnableKeyRotationInput) (req *aws.Request, output *EnableKeyRotationOutput) {
	if opEnableKeyRotation == nil {
		opEnableKeyRotation = &aws.Operation{
			Name:       "EnableKeyRotation",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	req = aws.NewRequest(c.Service, opEnableKeyRotation, input, output)
	output = &EnableKeyRotationOutput{}
	req.Data = output
	return
}

// Enables rotation of the specified customer master key.
func (c *KMS) EnableKeyRotation(input *EnableKeyRotationInput) (output *EnableKeyRotationOutput, err error) {
	req, out := c.EnableKeyRotationRequest(input)
	output = out
	err = req.Send()
	return
}

var opEnableKeyRotation *aws.Operation

// EncryptRequest generates a request for the Encrypt operation.
func (c *KMS) EncryptRequest(input *EncryptInput) (req *aws.Request, output *EncryptOutput) {
	if opEncrypt == nil {
		opEncrypt = &aws.Operation{
			Name:       "Encrypt",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	req = aws.NewRequest(c.Service, opEncrypt, input, output)
	output = &EncryptOutput{}
	req.Data = output
	return
}

// Encrypts plaintext into ciphertext by using a customer master key.
func (c *KMS) Encrypt(input *EncryptInput) (output *EncryptOutput, err error) {
	req, out := c.EncryptRequest(input)
	output = out
	err = req.Send()
	return
}

var opEncrypt *aws.Operation

// GenerateDataKeyRequest generates a request for the GenerateDataKey operation.
func (c *KMS) GenerateDataKeyRequest(input *GenerateDataKeyInput) (req *aws.Request, output *GenerateDataKeyOutput) {
	if opGenerateDataKey == nil {
		opGenerateDataKey = &aws.Operation{
			Name:       "GenerateDataKey",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	req = aws.NewRequest(c.Service, opGenerateDataKey, input, output)
	output = &GenerateDataKeyOutput{}
	req.Data = output
	return
}

// Generates a secure data key. Data keys are used to encrypt and decrypt data.
// They are wrapped by customer master keys.
func (c *KMS) GenerateDataKey(input *GenerateDataKeyInput) (output *GenerateDataKeyOutput, err error) {
	req, out := c.GenerateDataKeyRequest(input)
	output = out
	err = req.Send()
	return
}

var opGenerateDataKey *aws.Operation

// GenerateDataKeyWithoutPlaintextRequest generates a request for the GenerateDataKeyWithoutPlaintext operation.
func (c *KMS) GenerateDataKeyWithoutPlaintextRequest(input *GenerateDataKeyWithoutPlaintextInput) (req *aws.Request, output *GenerateDataKeyWithoutPlaintextOutput) {
	if opGenerateDataKeyWithoutPlaintext == nil {
		opGenerateDataKeyWithoutPlaintext = &aws.Operation{
			Name:       "GenerateDataKeyWithoutPlaintext",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	req = aws.NewRequest(c.Service, opGenerateDataKeyWithoutPlaintext, input, output)
	output = &GenerateDataKeyWithoutPlaintextOutput{}
	req.Data = output
	return
}

// Returns a key wrapped by a customer master key without the plaintext copy
// of that key. To retrieve the plaintext, see GenerateDataKey.
func (c *KMS) GenerateDataKeyWithoutPlaintext(input *GenerateDataKeyWithoutPlaintextInput) (output *GenerateDataKeyWithoutPlaintextOutput, err error) {
	req, out := c.GenerateDataKeyWithoutPlaintextRequest(input)
	output = out
	err = req.Send()
	return
}

var opGenerateDataKeyWithoutPlaintext *aws.Operation

// GenerateRandomRequest generates a request for the GenerateRandom operation.
func (c *KMS) GenerateRandomRequest(input *GenerateRandomInput) (req *aws.Request, output *GenerateRandomOutput) {
	if opGenerateRandom == nil {
		opGenerateRandom = &aws.Operation{
			Name:       "GenerateRandom",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	req = aws.NewRequest(c.Service, opGenerateRandom, input, output)
	output = &GenerateRandomOutput{}
	req.Data = output
	return
}

// Generates an unpredictable byte string.
func (c *KMS) GenerateRandom(input *GenerateRandomInput) (output *GenerateRandomOutput, err error) {
	req, out := c.GenerateRandomRequest(input)
	output = out
	err = req.Send()
	return
}

var opGenerateRandom *aws.Operation

// GetKeyPolicyRequest generates a request for the GetKeyPolicy operation.
func (c *KMS) GetKeyPolicyRequest(input *GetKeyPolicyInput) (req *aws.Request, output *GetKeyPolicyOutput) {
	if opGetKeyPolicy == nil {
		opGetKeyPolicy = &aws.Operation{
			Name:       "GetKeyPolicy",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	req = aws.NewRequest(c.Service, opGetKeyPolicy, input, output)
	output = &GetKeyPolicyOutput{}
	req.Data = output
	return
}

// Retrieves a policy attached to the specified key.
func (c *KMS) GetKeyPolicy(input *GetKeyPolicyInput) (output *GetKeyPolicyOutput, err error) {
	req, out := c.GetKeyPolicyRequest(input)
	output = out
	err = req.Send()
	return
}

var opGetKeyPolicy *aws.Operation

// GetKeyRotationStatusRequest generates a request for the GetKeyRotationStatus operation.
func (c *KMS) GetKeyRotationStatusRequest(input *GetKeyRotationStatusInput) (req *aws.Request, output *GetKeyRotationStatusOutput) {
	if opGetKeyRotationStatus == nil {
		opGetKeyRotationStatus = &aws.Operation{
			Name:       "GetKeyRotationStatus",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	req = aws.NewRequest(c.Service, opGetKeyRotationStatus, input, output)
	output = &GetKeyRotationStatusOutput{}
	req.Data = output
	return
}

// Retrieves a Boolean value that indicates whether key rotation is enabled
// for the specified key.
func (c *KMS) GetKeyRotationStatus(input *GetKeyRotationStatusInput) (output *GetKeyRotationStatusOutput, err error) {
	req, out := c.GetKeyRotationStatusRequest(input)
	output = out
	err = req.Send()
	return
}

var opGetKeyRotationStatus *aws.Operation

// ListAliasesRequest generates a request for the ListAliases operation.
func (c *KMS) ListAliasesRequest(input *ListAliasesInput) (req *aws.Request, output *ListAliasesOutput) {
	if opListAliases == nil {
		opListAliases = &aws.Operation{
			Name:       "ListAliases",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	req = aws.NewRequest(c.Service, opListAliases, input, output)
	output = &ListAliasesOutput{}
	req.Data = output
	return
}

// Lists all of the key aliases in the account.
func (c *KMS) ListAliases(input *ListAliasesInput) (output *ListAliasesOutput, err error) {
	req, out := c.ListAliasesRequest(input)
	output = out
	err = req.Send()
	return
}

var opListAliases *aws.Operation

// ListGrantsRequest generates a request for the ListGrants operation.
func (c *KMS) ListGrantsRequest(input *ListGrantsInput) (req *aws.Request, output *ListGrantsOutput) {
	if opListGrants == nil {
		opListGrants = &aws.Operation{
			Name:       "ListGrants",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	req = aws.NewRequest(c.Service, opListGrants, input, output)
	output = &ListGrantsOutput{}
	req.Data = output
	return
}

// List the grants for a specified key.
func (c *KMS) ListGrants(input *ListGrantsInput) (output *ListGrantsOutput, err error) {
	req, out := c.ListGrantsRequest(input)
	output = out
	err = req.Send()
	return
}

var opListGrants *aws.Operation

// ListKeyPoliciesRequest generates a request for the ListKeyPolicies operation.
func (c *KMS) ListKeyPoliciesRequest(input *ListKeyPoliciesInput) (req *aws.Request, output *ListKeyPoliciesOutput) {
	if opListKeyPolicies == nil {
		opListKeyPolicies = &aws.Operation{
			Name:       "ListKeyPolicies",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	req = aws.NewRequest(c.Service, opListKeyPolicies, input, output)
	output = &ListKeyPoliciesOutput{}
	req.Data = output
	return
}

// Retrieves a list of policies attached to a key.
func (c *KMS) ListKeyPolicies(input *ListKeyPoliciesInput) (output *ListKeyPoliciesOutput, err error) {
	req, out := c.ListKeyPoliciesRequest(input)
	output = out
	err = req.Send()
	return
}

var opListKeyPolicies *aws.Operation

// ListKeysRequest generates a request for the ListKeys operation.
func (c *KMS) ListKeysRequest(input *ListKeysInput) (req *aws.Request, output *ListKeysOutput) {
	if opListKeys == nil {
		opListKeys = &aws.Operation{
			Name:       "ListKeys",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	req = aws.NewRequest(c.Service, opListKeys, input, output)
	output = &ListKeysOutput{}
	req.Data = output
	return
}

// Lists the customer master keys.
func (c *KMS) ListKeys(input *ListKeysInput) (output *ListKeysOutput, err error) {
	req, out := c.ListKeysRequest(input)
	output = out
	err = req.Send()
	return
}

var opListKeys *aws.Operation

// PutKeyPolicyRequest generates a request for the PutKeyPolicy operation.
func (c *KMS) PutKeyPolicyRequest(input *PutKeyPolicyInput) (req *aws.Request, output *PutKeyPolicyOutput) {
	if opPutKeyPolicy == nil {
		opPutKeyPolicy = &aws.Operation{
			Name:       "PutKeyPolicy",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	req = aws.NewRequest(c.Service, opPutKeyPolicy, input, output)
	output = &PutKeyPolicyOutput{}
	req.Data = output
	return
}

// Attaches a policy to the specified key.
func (c *KMS) PutKeyPolicy(input *PutKeyPolicyInput) (output *PutKeyPolicyOutput, err error) {
	req, out := c.PutKeyPolicyRequest(input)
	output = out
	err = req.Send()
	return
}

var opPutKeyPolicy *aws.Operation

// ReEncryptRequest generates a request for the ReEncrypt operation.
func (c *KMS) ReEncryptRequest(input *ReEncryptInput) (req *aws.Request, output *ReEncryptOutput) {
	if opReEncrypt == nil {
		opReEncrypt = &aws.Operation{
			Name:       "ReEncrypt",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	req = aws.NewRequest(c.Service, opReEncrypt, input, output)
	output = &ReEncryptOutput{}
	req.Data = output
	return
}

// Encrypts data on the server side with a new customer master key without exposing
// the plaintext of the data on the client side. The data is first decrypted
// and then encrypted. This operation can also be used to change the encryption
// context of a ciphertext.
func (c *KMS) ReEncrypt(input *ReEncryptInput) (output *ReEncryptOutput, err error) {
	req, out := c.ReEncryptRequest(input)
	output = out
	err = req.Send()
	return
}

var opReEncrypt *aws.Operation

// RetireGrantRequest generates a request for the RetireGrant operation.
func (c *KMS) RetireGrantRequest(input *RetireGrantInput) (req *aws.Request, output *RetireGrantOutput) {
	if opRetireGrant == nil {
		opRetireGrant = &aws.Operation{
			Name:       "RetireGrant",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	req = aws.NewRequest(c.Service, opRetireGrant, input, output)
	output = &RetireGrantOutput{}
	req.Data = output
	return
}

// Retires a grant. You can retire a grant when you're done using it to clean
// up. You should revoke a grant when you intend to actively deny operations
// that depend on it.
func (c *KMS) RetireGrant(input *RetireGrantInput) (output *RetireGrantOutput, err error) {
	req, out := c.RetireGrantRequest(input)
	output = out
	err = req.Send()
	return
}

var opRetireGrant *aws.Operation

// RevokeGrantRequest generates a request for the RevokeGrant operation.
func (c *KMS) RevokeGrantRequest(input *RevokeGrantInput) (req *aws.Request, output *RevokeGrantOutput) {
	if opRevokeGrant == nil {
		opRevokeGrant = &aws.Operation{
			Name:       "RevokeGrant",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	req = aws.NewRequest(c.Service, opRevokeGrant, input, output)
	output = &RevokeGrantOutput{}
	req.Data = output
	return
}

// Revokes a grant. You can revoke a grant to actively deny operations that
// depend on it.
func (c *KMS) RevokeGrant(input *RevokeGrantInput) (output *RevokeGrantOutput, err error) {
	req, out := c.RevokeGrantRequest(input)
	output = out
	err = req.Send()
	return
}

var opRevokeGrant *aws.Operation

// UpdateKeyDescriptionRequest generates a request for the UpdateKeyDescription operation.
func (c *KMS) UpdateKeyDescriptionRequest(input *UpdateKeyDescriptionInput) (req *aws.Request, output *UpdateKeyDescriptionOutput) {
	if opUpdateKeyDescription == nil {
		opUpdateKeyDescription = &aws.Operation{
			Name:       "UpdateKeyDescription",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	req = aws.NewRequest(c.Service, opUpdateKeyDescription, input, output)
	output = &UpdateKeyDescriptionOutput{}
	req.Data = output
	return
}

func (c *KMS) UpdateKeyDescription(input *UpdateKeyDescriptionInput) (output *UpdateKeyDescriptionOutput, err error) {
	req, out := c.UpdateKeyDescriptionRequest(input)
	output = out
	err = req.Send()
	return
}

var opUpdateKeyDescription *aws.Operation

// Contains information about an alias.
type AliasListEntry struct {
	// String that contains the key ARN.
	AliasARN *string `locationName:"AliasArn" type:"string"`

	// String that contains the alias.
	AliasName *string `type:"string"`

	// String that contains the key identifier pointed to by the alias.
	TargetKeyID *string `locationName:"TargetKeyId" type:"string"`

	metadataAliasListEntry `json:"-", xml:"-"`
}

type metadataAliasListEntry struct {
	SDKShapeTraits bool `type:"structure"`
}

type CreateAliasInput struct {
	// String that contains the display name. Aliases that begin with AWS are reserved.
	AliasName *string `type:"string" required:"true"`

	// An identifier of the key for which you are creating the alias. This value
	// cannot be another alias.
	TargetKeyID *string `locationName:"TargetKeyId" type:"string" required:"true"`

	metadataCreateAliasInput `json:"-", xml:"-"`
}

type metadataCreateAliasInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type CreateAliasOutput struct {
	metadataCreateAliasOutput `json:"-", xml:"-"`
}

type metadataCreateAliasOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type CreateGrantInput struct {
	// Specifies the conditions under which the actions specified by the Operations
	// parameter are allowed.
	Constraints *GrantConstraints `type:"structure"`

	// List of grant tokens.
	GrantTokens []*string `type:"list"`

	// Principal given permission by the grant to use the key identified by the
	// keyId parameter.
	GranteePrincipal *string `type:"string" required:"true"`

	// A unique key identifier for a customer master key. This value can be a globally
	// unique identifier, an ARN, or an alias.
	KeyID *string `locationName:"KeyId" type:"string" required:"true"`

	// List of operations permitted by the grant. This can be any combination of
	// one or more of the following values:  Decrypt Encrypt GenerateDataKey GenerateDataKeyWithoutPlaintext
	// ReEncryptFrom ReEncryptTo CreateGrant
	Operations []*string `type:"list"`

	// Principal given permission to retire the grant. For more information, see
	// RetireGrant.
	RetiringPrincipal *string `type:"string"`

	metadataCreateGrantInput `json:"-", xml:"-"`
}

type metadataCreateGrantInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type CreateGrantOutput struct {
	// Unique grant identifier. You can use the GrantId value to revoke a grant.
	GrantID *string `locationName:"GrantId" type:"string"`

	// The grant token. A grant token is a string that identifies a grant and which
	// can be used to make a grant take effect immediately. A token contains all
	// of the information necessary to create a grant.
	GrantToken *string `type:"string"`

	metadataCreateGrantOutput `json:"-", xml:"-"`
}

type metadataCreateGrantOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type CreateKeyInput struct {
	// Description of the key. We recommend that you choose a description that helps
	// your customer decide whether the key is appropriate for a task.
	Description *string `type:"string"`

	// Specifies the intended use of the key. Currently this defaults to ENCRYPT/DECRYPT,
	// and only symmetric encryption and decryption are supported.
	KeyUsage *string `type:"string"`

	// Policy to be attached to the key. This is required and delegates back to
	// the account. The key is the root of trust.
	Policy *string `type:"string"`

	metadataCreateKeyInput `json:"-", xml:"-"`
}

type metadataCreateKeyInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type CreateKeyOutput struct {
	// Metadata associated with the key.
	KeyMetadata *KeyMetadata `type:"structure"`

	metadataCreateKeyOutput `json:"-", xml:"-"`
}

type metadataCreateKeyOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type DecryptInput struct {
	// Ciphertext including metadata.
	CiphertextBlob []byte `type:"blob" required:"true"`

	// The encryption context. If this was specified in the Encrypt function, it
	// must be specified here or the decryption operation will fail. For more information,
	// see Encryption Context (http://docs.aws.amazon.com/kms/latest/developerguide/encrypt-context.html).
	EncryptionContext *map[string]*string `type:"map"`

	// A list of grant tokens that represent grants which can be used to provide
	// long term permissions to perform decryption.
	GrantTokens []*string `type:"list"`

	metadataDecryptInput `json:"-", xml:"-"`
}

type metadataDecryptInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type DecryptOutput struct {
	// Unique identifier created by the system for the key. This value is always
	// returned as long as no errors are encountered during the operation.
	KeyID *string `locationName:"KeyId" type:"string"`

	// Decrypted plaintext data. This value may not be returned if the customer
	// master key is not available or if you didn't have permission to use it.
	Plaintext []byte `type:"blob"`

	metadataDecryptOutput `json:"-", xml:"-"`
}

type metadataDecryptOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type DeleteAliasInput struct {
	// The alias to be deleted.
	AliasName *string `type:"string" required:"true"`

	metadataDeleteAliasInput `json:"-", xml:"-"`
}

type metadataDeleteAliasInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type DeleteAliasOutput struct {
	metadataDeleteAliasOutput `json:"-", xml:"-"`
}

type metadataDeleteAliasOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type DescribeKeyInput struct {
	// Unique identifier of the customer master key to be described. This can be
	// an ARN, an alias, or a globally unique identifier.
	KeyID *string `locationName:"KeyId" type:"string" required:"true"`

	metadataDescribeKeyInput `json:"-", xml:"-"`
}

type metadataDescribeKeyInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type DescribeKeyOutput struct {
	// Metadata associated with the key.
	KeyMetadata *KeyMetadata `type:"structure"`

	metadataDescribeKeyOutput `json:"-", xml:"-"`
}

type metadataDescribeKeyOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type DisableKeyInput struct {
	// Unique identifier of the customer master key to be disabled. This can be
	// an ARN, an alias, or a globally unique identifier.
	KeyID *string `locationName:"KeyId" type:"string" required:"true"`

	metadataDisableKeyInput `json:"-", xml:"-"`
}

type metadataDisableKeyInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type DisableKeyOutput struct {
	metadataDisableKeyOutput `json:"-", xml:"-"`
}

type metadataDisableKeyOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type DisableKeyRotationInput struct {
	// Unique identifier of the customer master key for which rotation is to be
	// disabled. This can be an ARN, an alias, or a globally unique identifier.
	KeyID *string `locationName:"KeyId" type:"string" required:"true"`

	metadataDisableKeyRotationInput `json:"-", xml:"-"`
}

type metadataDisableKeyRotationInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type DisableKeyRotationOutput struct {
	metadataDisableKeyRotationOutput `json:"-", xml:"-"`
}

type metadataDisableKeyRotationOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type EnableKeyInput struct {
	// Unique identifier of the customer master key to be enabled. This can be an
	// ARN, an alias, or a globally unique identifier.
	KeyID *string `locationName:"KeyId" type:"string" required:"true"`

	metadataEnableKeyInput `json:"-", xml:"-"`
}

type metadataEnableKeyInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type EnableKeyOutput struct {
	metadataEnableKeyOutput `json:"-", xml:"-"`
}

type metadataEnableKeyOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type EnableKeyRotationInput struct {
	// Unique identifier of the customer master key for which rotation is to be
	// enabled. This can be an ARN, an alias, or a globally unique identifier.
	KeyID *string `locationName:"KeyId" type:"string" required:"true"`

	metadataEnableKeyRotationInput `json:"-", xml:"-"`
}

type metadataEnableKeyRotationInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type EnableKeyRotationOutput struct {
	metadataEnableKeyRotationOutput `json:"-", xml:"-"`
}

type metadataEnableKeyRotationOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type EncryptInput struct {
	// Name:value pair that specifies the encryption context to be used for authenticated
	// encryption. For more information, see Authenticated Encryption (http://docs.aws.amazon.com/kms/latest/developerguide/crypto_authen.html).
	EncryptionContext *map[string]*string `type:"map"`

	// A list of grant tokens that represent grants which can be used to provide
	// long term permissions to perform encryption.
	GrantTokens []*string `type:"list"`

	// Unique identifier of the customer master. This can be an ARN, an alias, or
	// the Key ID.
	KeyID *string `locationName:"KeyId" type:"string" required:"true"`

	// Data to be encrypted.
	Plaintext []byte `type:"blob" required:"true"`

	metadataEncryptInput `json:"-", xml:"-"`
}

type metadataEncryptInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type EncryptOutput struct {
	// The encrypted plaintext.
	CiphertextBlob []byte `type:"blob"`

	// The ID of the key used during encryption.
	KeyID *string `locationName:"KeyId" type:"string"`

	metadataEncryptOutput `json:"-", xml:"-"`
}

type metadataEncryptOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type GenerateDataKeyInput struct {
	// Name/value pair that contains additional data to be authenticated during
	// the encryption and decryption processes that use the key. This value is logged
	// by AWS CloudTrail to provide context around the data encrypted by the key.
	EncryptionContext *map[string]*string `type:"map"`

	// A list of grant tokens that represent grants which can be used to provide
	// long term permissions to generate a key.
	GrantTokens []*string `type:"list"`

	// Unique identifier of the key. This can be an ARN, an alias, or a globally
	// unique identifier.
	KeyID *string `locationName:"KeyId" type:"string" required:"true"`

	// Value that identifies the encryption algorithm and key size to generate a
	// data key for. Currently this can be AES_128 or AES_256.
	KeySpec *string `type:"string"`

	// Integer that contains the number of bytes to generate. Common values are
	// 128, 256, 512, 1024 and so on. 1024 is the current limit.
	NumberOfBytes *int64 `type:"integer"`

	metadataGenerateDataKeyInput `json:"-", xml:"-"`
}

type metadataGenerateDataKeyInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type GenerateDataKeyOutput struct {
	// Ciphertext that contains the wrapped key. You must store the blob and encryption
	// context so that the ciphertext can be decrypted. You must provide both the
	// ciphertext blob and the encryption context.
	CiphertextBlob []byte `type:"blob"`

	// System generated unique identifier for the key.
	KeyID *string `locationName:"KeyId" type:"string"`

	// Plaintext that contains the unwrapped key. Use this for encryption and decryption
	// and then remove it from memory as soon as possible.
	Plaintext []byte `type:"blob"`

	metadataGenerateDataKeyOutput `json:"-", xml:"-"`
}

type metadataGenerateDataKeyOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type GenerateDataKeyWithoutPlaintextInput struct {
	// Name:value pair that contains additional data to be authenticated during
	// the encryption and decryption processes.
	EncryptionContext *map[string]*string `type:"map"`

	// A list of grant tokens that represent grants which can be used to provide
	// long term permissions to generate a key.
	GrantTokens []*string `type:"list"`

	// Unique identifier of the key. This can be an ARN, an alias, or a globally
	// unique identifier.
	KeyID *string `locationName:"KeyId" type:"string" required:"true"`

	// Value that identifies the encryption algorithm and key size. Currently this
	// can be AES_128 or AES_256.
	KeySpec *string `type:"string"`

	// Integer that contains the number of bytes to generate. Common values are
	// 128, 256, 512, 1024 and so on.
	NumberOfBytes *int64 `type:"integer"`

	metadataGenerateDataKeyWithoutPlaintextInput `json:"-", xml:"-"`
}

type metadataGenerateDataKeyWithoutPlaintextInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type GenerateDataKeyWithoutPlaintextOutput struct {
	// Ciphertext that contains the wrapped key. You must store the blob and encryption
	// context so that the key can be used in a future operation.
	CiphertextBlob []byte `type:"blob"`

	// System generated unique identifier for the key.
	KeyID *string `locationName:"KeyId" type:"string"`

	metadataGenerateDataKeyWithoutPlaintextOutput `json:"-", xml:"-"`
}

type metadataGenerateDataKeyWithoutPlaintextOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type GenerateRandomInput struct {
	// Integer that contains the number of bytes to generate. Common values are
	// 128, 256, 512, 1024 and so on. The current limit is 1024 bytes.
	NumberOfBytes *int64 `type:"integer"`

	metadataGenerateRandomInput `json:"-", xml:"-"`
}

type metadataGenerateRandomInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type GenerateRandomOutput struct {
	// Plaintext that contains the unpredictable byte string.
	Plaintext []byte `type:"blob"`

	metadataGenerateRandomOutput `json:"-", xml:"-"`
}

type metadataGenerateRandomOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type GetKeyPolicyInput struct {
	// Unique identifier of the key. This can be an ARN, an alias, or a globally
	// unique identifier.
	KeyID *string `locationName:"KeyId" type:"string" required:"true"`

	// String that contains the name of the policy. Currently, this must be "default".
	// Policy names can be discovered by calling ListKeyPolicies.
	PolicyName *string `type:"string" required:"true"`

	metadataGetKeyPolicyInput `json:"-", xml:"-"`
}

type metadataGetKeyPolicyInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type GetKeyPolicyOutput struct {
	// A policy document in JSON format.
	Policy *string `type:"string"`

	metadataGetKeyPolicyOutput `json:"-", xml:"-"`
}

type metadataGetKeyPolicyOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type GetKeyRotationStatusInput struct {
	// Unique identifier of the key. This can be an ARN, an alias, or a globally
	// unique identifier.
	KeyID *string `locationName:"KeyId" type:"string" required:"true"`

	metadataGetKeyRotationStatusInput `json:"-", xml:"-"`
}

type metadataGetKeyRotationStatusInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type GetKeyRotationStatusOutput struct {
	// A Boolean value that specifies whether key rotation is enabled.
	KeyRotationEnabled *bool `type:"boolean"`

	metadataGetKeyRotationStatusOutput `json:"-", xml:"-"`
}

type metadataGetKeyRotationStatusOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

// Contains constraints on the grant.
type GrantConstraints struct {
	// The constraint contains additional key/value pairs that serve to further
	// limit the grant.
	EncryptionContextEquals *map[string]*string `type:"map"`

	// The constraint equals the full encryption context.
	EncryptionContextSubset *map[string]*string `type:"map"`

	metadataGrantConstraints `json:"-", xml:"-"`
}

type metadataGrantConstraints struct {
	SDKShapeTraits bool `type:"structure"`
}

// Contains information about each entry in the grant list.
type GrantListEntry struct {
	// Specifies the conditions under which the actions specified by the Operations
	// parameter are allowed.
	Constraints *GrantConstraints `type:"structure"`

	// Unique grant identifier.
	GrantID *string `locationName:"GrantId" type:"string"`

	// The principal that receives the grant permission.
	GranteePrincipal *string `type:"string"`

	// The account under which the grant was issued.
	IssuingAccount *string `type:"string"`

	// List of operations permitted by the grant. This can be any combination of
	// one or more of the following values:  Decrypt Encrypt GenerateDataKey GenerateDataKeyWithoutPlaintext
	// ReEncryptFrom ReEncryptTo CreateGrant
	Operations []*string `type:"list"`

	// The principal that can retire the account.
	RetiringPrincipal *string `type:"string"`

	metadataGrantListEntry `json:"-", xml:"-"`
}

type metadataGrantListEntry struct {
	SDKShapeTraits bool `type:"structure"`
}

// Contains information about each entry in the key list.
type KeyListEntry struct {
	// ARN of the key.
	KeyARN *string `locationName:"KeyArn" type:"string"`

	// Unique identifier of the key.
	KeyID *string `locationName:"KeyId" type:"string"`

	metadataKeyListEntry `json:"-", xml:"-"`
}

type metadataKeyListEntry struct {
	SDKShapeTraits bool `type:"structure"`
}

// Contains metadata associated with a specific key.
type KeyMetadata struct {
	// Key ARN (Amazon Resource Name).
	ARN *string `locationName:"Arn" type:"string"`

	// Account ID number.
	AWSAccountID *string `locationName:"AWSAccountId" type:"string"`

	// Date the key was created.
	CreationDate *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The description of the key.
	Description *string `type:"string"`

	// Value that specifies whether the key is enabled.
	Enabled *bool `type:"boolean"`

	// Unique identifier for the key.
	KeyID *string `locationName:"KeyId" type:"string" required:"true"`

	// A value that specifies what operation(s) the key can perform.
	KeyUsage *string `type:"string"`

	metadataKeyMetadata `json:"-", xml:"-"`
}

type metadataKeyMetadata struct {
	SDKShapeTraits bool `type:"structure"`
}

type ListAliasesInput struct {
	// Specify this parameter when paginating results to indicate the maximum number
	// of aliases you want in each response. If there are additional aliases beyond
	// the maximum you specify, the Truncated response element will be set to true.
	Limit *int64 `type:"integer"`

	// Use this parameter when paginating results, and only in a subsequent request
	// after you've received a response where the results are truncated. Set it
	// to the value of the NextMarker element in the response you just received.
	Marker *string `type:"string"`

	metadataListAliasesInput `json:"-", xml:"-"`
}

type metadataListAliasesInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type ListAliasesOutput struct {
	// A list of key aliases in the user's account.
	Aliases []*AliasListEntry `type:"list"`

	// If Truncated is true, this value is present and contains the value to use
	// for the Marker request parameter in a subsequent pagination request.
	NextMarker *string `type:"string"`

	// A flag that indicates whether there are more items in the list. If your results
	// were truncated, you can make a subsequent pagination request using the Marker
	// request parameter to retrieve more aliases in the list.
	Truncated *bool `type:"boolean"`

	metadataListAliasesOutput `json:"-", xml:"-"`
}

type metadataListAliasesOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type ListGrantsInput struct {
	// Unique identifier of the key. This can be an ARN, an alias, or a globally
	// unique identifier.
	KeyID *string `locationName:"KeyId" type:"string" required:"true"`

	// Specify this parameter only when paginating results to indicate the maximum
	// number of grants you want listed in the response. If there are additional
	// grants beyond the maximum you specify, the Truncated response element will
	// be set to true.
	Limit *int64 `type:"integer"`

	// Use this parameter only when paginating results, and only in a subsequent
	// request after you've received a response where the results are truncated.
	// Set it to the value of the NextMarker in the response you just received.
	Marker *string `type:"string"`

	metadataListGrantsInput `json:"-", xml:"-"`
}

type metadataListGrantsInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type ListGrantsOutput struct {
	// A list of grants.
	Grants []*GrantListEntry `type:"list"`

	// If Truncated is true, this value is present and contains the value to use
	// for the Marker request parameter in a subsequent pagination request.
	NextMarker *string `type:"string"`

	// A flag that indicates whether there are more items in the list. If your results
	// were truncated, you can make a subsequent pagination request using the Marker
	// request parameter to retrieve more grants in the list.
	Truncated *bool `type:"boolean"`

	metadataListGrantsOutput `json:"-", xml:"-"`
}

type metadataListGrantsOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type ListKeyPoliciesInput struct {
	// Unique identifier of the key. This can be an ARN, an alias, or a globally
	// unique identifier.
	KeyID *string `locationName:"KeyId" type:"string" required:"true"`

	// Specify this parameter only when paginating results to indicate the maximum
	// number of policies you want listed in the response. If there are additional
	// policies beyond the maximum you specify, the Truncated response element will
	// be set to true.
	Limit *int64 `type:"integer"`

	// Use this parameter only when paginating results, and only in a subsequent
	// request after you've received a response where the results are truncated.
	// Set it to the value of the NextMarker in the response you just received.
	Marker *string `type:"string"`

	metadataListKeyPoliciesInput `json:"-", xml:"-"`
}

type metadataListKeyPoliciesInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type ListKeyPoliciesOutput struct {
	// If Truncated is true, this value is present and contains the value to use
	// for the Marker request parameter in a subsequent pagination request.
	NextMarker *string `type:"string"`

	// A list of policy names. Currently, there is only one policy and it is named
	// "Default".
	PolicyNames []*string `type:"list"`

	// A flag that indicates whether there are more items in the list. If your results
	// were truncated, you can make a subsequent pagination request using the Marker
	// request parameter to retrieve more policies in the list.
	Truncated *bool `type:"boolean"`

	metadataListKeyPoliciesOutput `json:"-", xml:"-"`
}

type metadataListKeyPoliciesOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type ListKeysInput struct {
	// Specify this parameter only when paginating results to indicate the maximum
	// number of keys you want listed in the response. If there are additional keys
	// beyond the maximum you specify, the Truncated response element will be set
	// to true.
	Limit *int64 `type:"integer"`

	// Use this parameter only when paginating results, and only in a subsequent
	// request after you've received a response where the results are truncated.
	// Set it to the value of the NextMarker in the response you just received.
	Marker *string `type:"string"`

	metadataListKeysInput `json:"-", xml:"-"`
}

type metadataListKeysInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type ListKeysOutput struct {
	// A list of keys.
	Keys []*KeyListEntry `type:"list"`

	// If Truncated is true, this value is present and contains the value to use
	// for the Marker request parameter in a subsequent pagination request.
	NextMarker *string `type:"string"`

	// A flag that indicates whether there are more items in the list. If your results
	// were truncated, you can make a subsequent pagination request using the Marker
	// request parameter to retrieve more keys in the list.
	Truncated *bool `type:"boolean"`

	metadataListKeysOutput `json:"-", xml:"-"`
}

type metadataListKeysOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type PutKeyPolicyInput struct {
	// Unique identifier of the key. This can be an ARN, an alias, or a globally
	// unique identifier.
	KeyID *string `locationName:"KeyId" type:"string" required:"true"`

	// The policy, in JSON format, to be attached to the key.
	Policy *string `type:"string" required:"true"`

	// Name of the policy to be attached. Currently, the only supported name is
	// "default".
	PolicyName *string `type:"string" required:"true"`

	metadataPutKeyPolicyInput `json:"-", xml:"-"`
}

type metadataPutKeyPolicyInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type PutKeyPolicyOutput struct {
	metadataPutKeyPolicyOutput `json:"-", xml:"-"`
}

type metadataPutKeyPolicyOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type ReEncryptInput struct {
	// Ciphertext of the data to re-encrypt.
	CiphertextBlob []byte `type:"blob" required:"true"`

	// Encryption context to be used when the data is re-encrypted.
	DestinationEncryptionContext *map[string]*string `type:"map"`

	// Key identifier of the key used to re-encrypt the data.
	DestinationKeyID *string `locationName:"DestinationKeyId" type:"string" required:"true"`

	// Grant tokens that identify the grants that have permissions for the encryption
	// and decryption process.
	GrantTokens []*string `type:"list"`

	// Encryption context used to encrypt and decrypt the data specified in the
	// CiphertextBlob parameter.
	SourceEncryptionContext *map[string]*string `type:"map"`

	metadataReEncryptInput `json:"-", xml:"-"`
}

type metadataReEncryptInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type ReEncryptOutput struct {
	// The re-encrypted data.
	CiphertextBlob []byte `type:"blob"`

	// Unique identifier of the key used to re-encrypt the data.
	KeyID *string `locationName:"KeyId" type:"string"`

	// Unique identifier of the key used to originally encrypt the data.
	SourceKeyID *string `locationName:"SourceKeyId" type:"string"`

	metadataReEncryptOutput `json:"-", xml:"-"`
}

type metadataReEncryptOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type RetireGrantInput struct {
	// Token that identifies the grant to be retired.
	GrantToken *string `type:"string" required:"true"`

	metadataRetireGrantInput `json:"-", xml:"-"`
}

type metadataRetireGrantInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type RetireGrantOutput struct {
	metadataRetireGrantOutput `json:"-", xml:"-"`
}

type metadataRetireGrantOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type RevokeGrantInput struct {
	// Identifier of the grant to be revoked.
	GrantID *string `locationName:"GrantId" type:"string" required:"true"`

	// Unique identifier of the key associated with the grant.
	KeyID *string `locationName:"KeyId" type:"string" required:"true"`

	metadataRevokeGrantInput `json:"-", xml:"-"`
}

type metadataRevokeGrantInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type RevokeGrantOutput struct {
	metadataRevokeGrantOutput `json:"-", xml:"-"`
}

type metadataRevokeGrantOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type UpdateKeyDescriptionInput struct {
	Description *string `type:"string" required:"true"`

	KeyID *string `locationName:"KeyId" type:"string" required:"true"`

	metadataUpdateKeyDescriptionInput `json:"-", xml:"-"`
}

type metadataUpdateKeyDescriptionInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type UpdateKeyDescriptionOutput struct {
	metadataUpdateKeyDescriptionOutput `json:"-", xml:"-"`
}

type metadataUpdateKeyDescriptionOutput struct {
	SDKShapeTraits bool `type:"structure"`
}