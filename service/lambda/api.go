////////////////////////////////////////////////////////
// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. //
////////////////////////////////////////////////////////

// Lambda this is the AWS Lambda API Reference. The AWS Lambda Developer
// Guide provides additional information. For the service overview, go to
// What is AWS Lambda , and for information about how the service works, go
// to AWS LambdaL How it Works in the AWS Lambda Developer Guide.
package lambda

import (
	"time"

	"github.com/awslabs/aws-sdk-go/aws"
)

// AddEventSourceRequest generates a request for the AddEventSource operation.
func (c *Lambda) AddEventSourceRequest(input *AddEventSourceInput) (req *aws.Request, output *EventSourceConfiguration) {
	if opAddEventSource == nil {
		opAddEventSource = &aws.Operation{
			Name:       "AddEventSource",
			HTTPMethod: "POST",
			HTTPPath:   "/2014-11-13/event-source-mappings/",

			OperationBindings: &aws.OperationBindings{
				InPayload:   "",
				OutPayload:  "",
				Required:    []string{"EventSource", "FunctionName", "Role"},
				QueryParams: []string{},
				URIParams:   []string{},
				InHeaders:   []string{},
				OutHeaders:  []string{},
			},
		}
	}

	req = aws.NewRequest(c.Service, opAddEventSource, input, output)
	output = &EventSourceConfiguration{}
	req.Data = output
	return
}

// AddEventSource identifies an Amazon Kinesis stream as the event source
// for an AWS Lambda function. AWS Lambda invokes the specified function
// when records are posted to the stream. This is the pull model, where AWS
// Lambda invokes the function. For more information, go to AWS LambdaL How
// it Works in the AWS Lambda Developer Guide. This association between an
// Amazon Kinesis stream and an AWS Lambda function is called the event
// source mapping. You provide the configuration information (for example,
// which stream to read from and which AWS Lambda function to invoke) for
// the event source mapping in the request body. This operation requires
// permission for the iam:PassRole action for the IAM role. It also
// requires permission for the lambda:AddEventSource action.
func (c *Lambda) AddEventSource(input *AddEventSourceInput) (output *EventSourceConfiguration, err error) {
	req, out := c.AddEventSourceRequest(input)
	output = out
	err = req.Send()
	return
}

// DeleteFunctionRequest generates a request for the DeleteFunction operation.
func (c *Lambda) DeleteFunctionRequest(input *DeleteFunctionInput) (req *aws.Request) {
	if opDeleteFunction == nil {
		opDeleteFunction = &aws.Operation{
			Name:       "DeleteFunction",
			HTTPMethod: "DELETE",
			HTTPPath:   "/2014-11-13/functions/{FunctionName}",

			OperationBindings: &aws.OperationBindings{
				InPayload: "",

				Required:    []string{"FunctionName"},
				QueryParams: []string{},
				URIParams:   []string{"FunctionName"},
				InHeaders:   []string{},
				OutHeaders:  []string{},
			},
		}
	}

	req = aws.NewRequest(c.Service, opDeleteFunction, input, nil)

	return
}

// DeleteFunction deletes the specified Lambda function code and
// configuration. This operation requires permission for the
// lambda:DeleteFunction action.
func (c *Lambda) DeleteFunction(input *DeleteFunctionInput) (err error) {
	req := c.DeleteFunctionRequest(input)
	err = req.Send()
	return
}

// GetEventSourceRequest generates a request for the GetEventSource operation.
func (c *Lambda) GetEventSourceRequest(input *GetEventSourceInput) (req *aws.Request, output *EventSourceConfiguration) {
	if opGetEventSource == nil {
		opGetEventSource = &aws.Operation{
			Name:       "GetEventSource",
			HTTPMethod: "GET",
			HTTPPath:   "/2014-11-13/event-source-mappings/{UUID}",

			OperationBindings: &aws.OperationBindings{
				InPayload:   "",
				OutPayload:  "",
				Required:    []string{"UUID"},
				QueryParams: []string{},
				URIParams:   []string{"UUID"},
				InHeaders:   []string{},
				OutHeaders:  []string{},
			},
		}
	}

	req = aws.NewRequest(c.Service, opGetEventSource, input, output)
	output = &EventSourceConfiguration{}
	req.Data = output
	return
}

// GetEventSource returns configuration information for the specified event
// source mapping (see AddEventSource This operation requires permission
// for the lambda:GetEventSource action.
func (c *Lambda) GetEventSource(input *GetEventSourceInput) (output *EventSourceConfiguration, err error) {
	req, out := c.GetEventSourceRequest(input)
	output = out
	err = req.Send()
	return
}

// GetFunctionRequest generates a request for the GetFunction operation.
func (c *Lambda) GetFunctionRequest(input *GetFunctionInput) (req *aws.Request, output *GetFunctionOutput) {
	if opGetFunction == nil {
		opGetFunction = &aws.Operation{
			Name:       "GetFunction",
			HTTPMethod: "GET",
			HTTPPath:   "/2014-11-13/functions/{FunctionName}",

			OperationBindings: &aws.OperationBindings{
				InPayload:   "",
				OutPayload:  "",
				Required:    []string{"FunctionName"},
				QueryParams: []string{},
				URIParams:   []string{"FunctionName"},
				InHeaders:   []string{},
				OutHeaders:  []string{},
			},
		}
	}

	req = aws.NewRequest(c.Service, opGetFunction, input, output)
	output = &GetFunctionOutput{}
	req.Data = output
	return
}

// GetFunction returns the configuration information of the Lambda function
// and a presigned URL link to the .zip file you uploaded with
// UploadFunction so you can download the .zip file. Note that the URL is
// valid for up to 10 minutes. The configuration information is the same
// information you provided as parameters when uploading the function. This
// operation requires permission for the lambda:GetFunction action.
func (c *Lambda) GetFunction(input *GetFunctionInput) (output *GetFunctionOutput, err error) {
	req, out := c.GetFunctionRequest(input)
	output = out
	err = req.Send()
	return
}

// GetFunctionConfigurationRequest generates a request for the GetFunctionConfiguration operation.
func (c *Lambda) GetFunctionConfigurationRequest(input *GetFunctionConfigurationInput) (req *aws.Request, output *FunctionConfiguration) {
	if opGetFunctionConfiguration == nil {
		opGetFunctionConfiguration = &aws.Operation{
			Name:       "GetFunctionConfiguration",
			HTTPMethod: "GET",
			HTTPPath:   "/2014-11-13/functions/{FunctionName}/configuration",

			OperationBindings: &aws.OperationBindings{
				InPayload:   "",
				OutPayload:  "",
				Required:    []string{"FunctionName"},
				QueryParams: []string{},
				URIParams:   []string{"FunctionName"},
				InHeaders:   []string{},
				OutHeaders:  []string{},
			},
		}
	}

	req = aws.NewRequest(c.Service, opGetFunctionConfiguration, input, output)
	output = &FunctionConfiguration{}
	req.Data = output
	return
}

// GetFunctionConfiguration returns the configuration information of the
// Lambda function. This the same information you provided as parameters
// when uploading the function by using UploadFunction This operation
// requires permission for the lambda:GetFunctionConfiguration operation.
func (c *Lambda) GetFunctionConfiguration(input *GetFunctionConfigurationInput) (output *FunctionConfiguration, err error) {
	req, out := c.GetFunctionConfigurationRequest(input)
	output = out
	err = req.Send()
	return
}

// InvokeAsyncRequest generates a request for the InvokeAsync operation.
func (c *Lambda) InvokeAsyncRequest(input *InvokeAsyncInput) (req *aws.Request, output *InvokeAsyncOutput) {
	if opInvokeAsync == nil {
		opInvokeAsync = &aws.Operation{
			Name:       "InvokeAsync",
			HTTPMethod: "POST",
			HTTPPath:   "/2014-11-13/functions/{FunctionName}/invoke-async/",

			OperationBindings: &aws.OperationBindings{
				InPayload:   "InvokeArgs",
				OutPayload:  "",
				Required:    []string{"FunctionName", "InvokeArgs"},
				QueryParams: []string{},
				URIParams:   []string{"FunctionName"},
				InHeaders:   []string{},
				OutHeaders:  []string{},
			},
		}
	}

	req = aws.NewRequest(c.Service, opInvokeAsync, input, output)
	output = &InvokeAsyncOutput{}
	req.Data = output
	return
}

// InvokeAsync submits an invocation request to AWS Lambda. Upon receiving
// the request, Lambda executes the specified function asynchronously. To
// see the logs generated by the Lambda function execution, see the
// CloudWatch logs console. This operation requires permission for the
// lambda:InvokeAsync action.
func (c *Lambda) InvokeAsync(input *InvokeAsyncInput) (output *InvokeAsyncOutput, err error) {
	req, out := c.InvokeAsyncRequest(input)
	output = out
	err = req.Send()
	return
}

// ListEventSourcesRequest generates a request for the ListEventSources operation.
func (c *Lambda) ListEventSourcesRequest(input *ListEventSourcesInput) (req *aws.Request, output *ListEventSourcesOutput) {
	if opListEventSources == nil {
		opListEventSources = &aws.Operation{
			Name:       "ListEventSources",
			HTTPMethod: "GET",
			HTTPPath:   "/2014-11-13/event-source-mappings/",

			OperationBindings: &aws.OperationBindings{
				InPayload:   "",
				OutPayload:  "",
				Required:    []string{},
				QueryParams: []string{},
				URIParams:   []string{},
				InHeaders:   []string{},
				OutHeaders:  []string{},
			},
		}
	}

	req = aws.NewRequest(c.Service, opListEventSources, input, output)
	output = &ListEventSourcesOutput{}
	req.Data = output
	return
}

// ListEventSources returns a list of event source mappings. For each
// mapping, the API returns configuration information (see AddEventSource
// ). You can optionally specify filters to retrieve specific event source
// mappings. This operation requires permission for the
// lambda:ListEventSources action.
func (c *Lambda) ListEventSources(input *ListEventSourcesInput) (output *ListEventSourcesOutput, err error) {
	req, out := c.ListEventSourcesRequest(input)
	output = out
	err = req.Send()
	return
}

// ListFunctionsRequest generates a request for the ListFunctions operation.
func (c *Lambda) ListFunctionsRequest(input *ListFunctionsInput) (req *aws.Request, output *ListFunctionsOutput) {
	if opListFunctions == nil {
		opListFunctions = &aws.Operation{
			Name:       "ListFunctions",
			HTTPMethod: "GET",
			HTTPPath:   "/2014-11-13/functions/",

			OperationBindings: &aws.OperationBindings{
				InPayload:   "",
				OutPayload:  "",
				Required:    []string{},
				QueryParams: []string{},
				URIParams:   []string{},
				InHeaders:   []string{},
				OutHeaders:  []string{},
			},
		}
	}

	req = aws.NewRequest(c.Service, opListFunctions, input, output)
	output = &ListFunctionsOutput{}
	req.Data = output
	return
}

// ListFunctions returns a list of your Lambda functions. For each
// function, the response includes the function configuration information.
// You must use GetFunction to retrieve the code for your function. This
// operation requires permission for the lambda:ListFunctions action.
func (c *Lambda) ListFunctions(input *ListFunctionsInput) (output *ListFunctionsOutput, err error) {
	req, out := c.ListFunctionsRequest(input)
	output = out
	err = req.Send()
	return
}

// RemoveEventSourceRequest generates a request for the RemoveEventSource operation.
func (c *Lambda) RemoveEventSourceRequest(input *RemoveEventSourceInput) (req *aws.Request) {
	if opRemoveEventSource == nil {
		opRemoveEventSource = &aws.Operation{
			Name:       "RemoveEventSource",
			HTTPMethod: "DELETE",
			HTTPPath:   "/2014-11-13/event-source-mappings/{UUID}",

			OperationBindings: &aws.OperationBindings{
				InPayload: "",

				Required:    []string{"UUID"},
				QueryParams: []string{},
				URIParams:   []string{"UUID"},
				InHeaders:   []string{},
				OutHeaders:  []string{},
			},
		}
	}

	req = aws.NewRequest(c.Service, opRemoveEventSource, input, nil)

	return
}

// RemoveEventSource removes an event source mapping. This means AWS Lambda
// will no longer invoke the function for events in the associated source.
// This operation requires permission for the lambda:RemoveEventSource
// action.
func (c *Lambda) RemoveEventSource(input *RemoveEventSourceInput) (err error) {
	req := c.RemoveEventSourceRequest(input)
	err = req.Send()
	return
}

// UpdateFunctionConfigurationRequest generates a request for the UpdateFunctionConfiguration operation.
func (c *Lambda) UpdateFunctionConfigurationRequest(input *UpdateFunctionConfigurationInput) (req *aws.Request, output *FunctionConfiguration) {
	if opUpdateFunctionConfiguration == nil {
		opUpdateFunctionConfiguration = &aws.Operation{
			Name:       "UpdateFunctionConfiguration",
			HTTPMethod: "PUT",
			HTTPPath:   "/2014-11-13/functions/{FunctionName}/configuration",

			OperationBindings: &aws.OperationBindings{
				InPayload:   "",
				OutPayload:  "",
				Required:    []string{"FunctionName"},
				QueryParams: []string{},
				URIParams:   []string{"FunctionName"},
				InHeaders:   []string{},
				OutHeaders:  []string{},
			},
		}
	}

	req = aws.NewRequest(c.Service, opUpdateFunctionConfiguration, input, output)
	output = &FunctionConfiguration{}
	req.Data = output
	return
}

// UpdateFunctionConfiguration updates the configuration parameters for the
// specified Lambda function by using the values provided in the request.
// You provide only the parameters you want to change. This operation must
// only be used on an existing Lambda function and cannot be used to update
// the function's code. This operation requires permission for the
// lambda:UpdateFunctionConfiguration action.
func (c *Lambda) UpdateFunctionConfiguration(input *UpdateFunctionConfigurationInput) (output *FunctionConfiguration, err error) {
	req, out := c.UpdateFunctionConfigurationRequest(input)
	output = out
	err = req.Send()
	return
}

// UploadFunctionRequest generates a request for the UploadFunction operation.
func (c *Lambda) UploadFunctionRequest(input *UploadFunctionInput) (req *aws.Request, output *FunctionConfiguration) {
	if opUploadFunction == nil {
		opUploadFunction = &aws.Operation{
			Name:       "UploadFunction",
			HTTPMethod: "PUT",
			HTTPPath:   "/2014-11-13/functions/{FunctionName}",

			OperationBindings: &aws.OperationBindings{
				InPayload:   "FunctionZip",
				OutPayload:  "",
				Required:    []string{"FunctionName", "FunctionZip", "Handler", "Mode", "Role", "Runtime"},
				QueryParams: []string{},
				URIParams:   []string{"FunctionName"},
				InHeaders:   []string{},
				OutHeaders:  []string{},
			},
		}
	}

	req = aws.NewRequest(c.Service, opUploadFunction, input, output)
	output = &FunctionConfiguration{}
	req.Data = output
	return
}

// UploadFunction creates a new Lambda function or updates an existing
// function. The function metadata is created from the request parameters,
// and the code for the function is provided by a .zip file in the request
// body. If the function name already exists, the existing Lambda function
// is updated with the new code and metadata. This operation requires
// permission for the lambda:UploadFunction action.
func (c *Lambda) UploadFunction(input *UploadFunctionInput) (output *FunctionConfiguration, err error) {
	req, out := c.UploadFunctionRequest(input)
	output = out
	err = req.Send()
	return
}

var (
	opAddEventSource              *aws.Operation
	opDeleteFunction              *aws.Operation
	opGetEventSource              *aws.Operation
	opGetFunction                 *aws.Operation
	opGetFunctionConfiguration    *aws.Operation
	opInvokeAsync                 *aws.Operation
	opListEventSources            *aws.Operation
	opListFunctions               *aws.Operation
	opRemoveEventSource           *aws.Operation
	opUpdateFunctionConfiguration *aws.Operation
	opUploadFunction              *aws.Operation
)

// Possible values for Mode.
const (
	ModeEvent = "event"
)

// Possible values for Runtime.
const (
	RuntimeNodejs = "nodejs"
)

// AddEventSourceInput is undocumented.
type AddEventSourceInput struct {
	BatchSize    *int              `json:"BatchSize,omitempty"`
	EventSource  *string           `json:"EventSource"`
	FunctionName *string           `json:"FunctionName"`
	Parameters   map[string]string `json:"Parameters,omitempty"`
	Role         *string           `json:"Role"`
}

// DeleteFunctionInput is undocumented.
type DeleteFunctionInput struct {
	FunctionName *string `json:"-"`
}

// EventSourceConfiguration is undocumented.
type EventSourceConfiguration struct {
	BatchSize    *int              `json:"BatchSize,omitempty"`
	EventSource  *string           `json:"EventSource,omitempty"`
	FunctionName *string           `json:"FunctionName,omitempty"`
	IsActive     *bool             `json:"IsActive,omitempty"`
	LastModified time.Time         `json:"LastModified,omitempty"`
	Parameters   map[string]string `json:"Parameters,omitempty"`
	Role         *string           `json:"Role,omitempty"`
	Status       *string           `json:"Status,omitempty"`
	UUID         *string           `json:"UUID,omitempty"`
}

// FunctionCodeLocation is undocumented.
type FunctionCodeLocation struct {
	Location       *string `json:"Location,omitempty"`
	RepositoryType *string `json:"RepositoryType,omitempty"`
}

// FunctionConfiguration is undocumented.
type FunctionConfiguration struct {
	CodeSize        *int64    `json:"CodeSize,omitempty"`
	ConfigurationID *string   `json:"ConfigurationId,omitempty"`
	Description     *string   `json:"Description,omitempty"`
	FunctionARN     *string   `json:"FunctionARN,omitempty"`
	FunctionName    *string   `json:"FunctionName,omitempty"`
	Handler         *string   `json:"Handler,omitempty"`
	LastModified    time.Time `json:"LastModified,omitempty"`
	MemorySize      *int      `json:"MemorySize,omitempty"`
	Mode            *string   `json:"Mode,omitempty"`
	Role            *string   `json:"Role,omitempty"`
	Runtime         *string   `json:"Runtime,omitempty"`
	Timeout         *int      `json:"Timeout,omitempty"`
}

// GetEventSourceInput is undocumented.
type GetEventSourceInput struct {
	UUID *string `json:"-"`
}

// GetFunctionConfigurationInput is undocumented.
type GetFunctionConfigurationInput struct {
	FunctionName *string `json:"-"`
}

// GetFunctionInput is undocumented.
type GetFunctionInput struct {
	FunctionName *string `json:"-"`
}

// GetFunctionOutput is undocumented.
type GetFunctionOutput struct {
	Code          *FunctionCodeLocation  `json:"Code,omitempty"`
	Configuration *FunctionConfiguration `json:"Configuration,omitempty"`
}

// InvokeAsyncInput is undocumented.
type InvokeAsyncInput struct {
	FunctionName *string `json:"-"`
	InvokeArgs   []byte  `json:"InvokeArgs"`
}

// InvokeAsyncOutput is undocumented.
type InvokeAsyncOutput struct {
	Status *int `json:"-"`
}

// ListEventSourcesInput is undocumented.
type ListEventSourcesInput struct {
	EventSourceARN *string `json:"-"`
	FunctionName   *string `json:"-"`
	Marker         *string `json:"-"`
	MaxItems       *int    `json:"-"`
}

// ListEventSourcesOutput is undocumented.
type ListEventSourcesOutput struct {
	EventSources []EventSourceConfiguration `json:"EventSources,omitempty"`
	NextMarker   *string                    `json:"NextMarker,omitempty"`
}

// ListFunctionsInput is undocumented.
type ListFunctionsInput struct {
	Marker   *string `json:"-"`
	MaxItems *int    `json:"-"`
}

// ListFunctionsOutput is undocumented.
type ListFunctionsOutput struct {
	Functions  []FunctionConfiguration `json:"Functions,omitempty"`
	NextMarker *string                 `json:"NextMarker,omitempty"`
}

// RemoveEventSourceInput is undocumented.
type RemoveEventSourceInput struct {
	UUID *string `json:"-"`
}

// UpdateFunctionConfigurationInput is undocumented.
type UpdateFunctionConfigurationInput struct {
	Description  *string `json:"-"`
	FunctionName *string `json:"-"`
	Handler      *string `json:"-"`
	MemorySize   *int    `json:"-"`
	Role         *string `json:"-"`
	Timeout      *int    `json:"-"`
}

// UploadFunctionInput is undocumented.
type UploadFunctionInput struct {
	Description  *string `json:"-"`
	FunctionName *string `json:"-"`
	FunctionZip  []byte  `json:"FunctionZip"`
	Handler      *string `json:"-"`
	MemorySize   *int    `json:"-"`
	Mode         *string `json:"-"`
	Role         *string `json:"-"`
	Runtime      *string `json:"-"`
	Timeout      *int    `json:"-"`
}

// avoid errors if the packages aren't referenced
var _ time.Time
