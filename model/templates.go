package model

import (
	"bytes"
	"go/format"
	"io"
	"os"
	"path/filepath"
	"text/template"
)

// Generate writes a Go file with a client for using the parsed service.
func Generate(prefix string, forceService bool) error {
	pkg := service.PackageName()
	pkgDir := filepath.Join(prefix, pkg)
	os.MkdirAll(pkgDir, 0775)

	apiFile := filepath.Join(pkgDir, "api.go")
	apiWriter, err := os.Create(apiFile)
	if err != nil {
		panic(err)
	}
	defer apiWriter.Close()

	var svcWriter io.WriteCloser
	svcFile := filepath.Join(pkgDir, "service.go")
	if _, err := os.Stat(svcFile); forceService || (err != nil && os.IsNotExist(err)) {
		svcWriter, err = os.Create(svcFile)
		if err != nil {
			panic(err)
		}
		defer svcWriter.Close()
	}

	return generateSource(apiWriter, svcWriter)
}

func generateSource(api io.Writer, svc io.Writer) error {
	fmap := template.FuncMap{
		"godoc":            godoc,
		"exportable":       exportable,
		"structName":       structName,
		"enumList":         enumList,
		"shapeList":        shapeList,
		"shapeAlias":       shapeAlias,
		"protocolPackage":  protocolPackage,
		"requiredTraits":   requiredTraits,
		"locationTraits":   locationTraits,
		"hasRequiredTrait": hasRequiredTrait,
	}

	apiTemplate := template.New("api-root").Funcs(fmap)
	template.Must(tplAPI(apiTemplate))

	svcTemplate := template.New("service-root").Funcs(fmap)
	template.Must(tplService(svcTemplate))

	if api != nil {
		apiOut := new(bytes.Buffer)
		if err := apiTemplate.Execute(apiOut, service); err != nil {
			return err
		}
		apiFormatted, err := format.Source(apiOut.Bytes())
		if err != nil {
			return err
		}
		_, err = api.Write(apiFormatted)
		if err != nil {
			_, _ = api.Write(apiOut.Bytes())
			return err
		}
	}

	if svc != nil {
		svcOut := new(bytes.Buffer)
		if err := svcTemplate.Execute(svcOut, service); err != nil {
			return err
		}

		svcFormatted, err := format.Source(svcOut.Bytes())
		if err != nil {
			return err
		}

		_, err = svc.Write(svcFormatted)
		if err != nil {
			_, _ = svc.Write(svcOut.Bytes())
			return err
		}
	}

	return nil
}

func tplService(t *template.Template) (*template.Template, error) {
	return t.Parse(`
package {{ .PackageName }}

import (
    "github.com/awslabs/aws-sdk-go/aws"
    "github.com/awslabs/aws-sdk-go/aws/signer/v4"
    "github.com/awslabs/aws-sdk-go/aws/protocol/{{ protocolPackage .Metadata.Protocol }}"
)

// {{ .Name }} is a client for {{ .FullName }}.
type {{ .Name }} struct {
    *aws.Service
}

type {{ .Name }}Config struct {
    *aws.Config
}

// New returns a new {{ .Name }} client.
func New(config *{{ .Name }}Config) *{{ .Name }} {
  if config == nil {
    config = &{{ .Name }}Config{}
  }

  service := &aws.Service{
    Config:       aws.DefaultConfig.Merge(config.Config),
    ServiceName:  "{{ .Metadata.EndpointPrefix }}",
    APIVersion:   "{{ .Metadata.APIVersion }}",
{{ if eq .Metadata.Protocol "json" }}JSONVersion:  "{{ .Metadata.JSONVersion }}",
    TargetPrefix: "{{ .Metadata.TargetPrefix }}",
{{ end }}
  }
  service.Initialize()

  // Handlers
  service.Handlers.Sign.PushBack(v4.Sign)
  service.Handlers.Build.PushBack({{ protocolPackage .Metadata.Protocol }}.Build)
  service.Handlers.Unmarshal.PushBack({{ protocolPackage .Metadata.Protocol }}.Unmarshal)

  return &{{ .Name }}{service}
}
`)
}

func tplAPI(t *template.Template) (*template.Template, error) {
	template.Must(tplAPIHeader(t))
	template.Must(tplAPIOperations(t))
	template.Must(tplAPIShapes(t))
	template.Must(tplAPIFooter(t))
	return t.Parse(`
{{ template "api-header" $ }}
{{ template "api-operations" $ }}
{{ template "api-shapes" $ }}
{{ template "api-footer" }}
`)
}

func tplAPIHeader(t *template.Template) (*template.Template, error) {
	return t.Parse(`
{{ define "api-header" }}
////////////////////////////////////////////////////////
// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. //
////////////////////////////////////////////////////////

{{ godoc .Name .Documentation }} package {{ .PackageName }}

import (
  "time"

  "github.com/awslabs/aws-sdk-go/aws"
)

{{ end }}
`)
}

func tplAPIFooter(t *template.Template) (*template.Template, error) {
	return t.Parse(`
{{ define "api-footer" }}
// avoid errors if the packages aren't referenced
var _ time.Time
var _ xml.Decoder
var _ = io.EOF
{{ end }}
`)
}

func tplAPIOperations(t *template.Template) (*template.Template, error) {
	return t.Parse(`
{{ define "api-operations" }}

{{ range $name, $op := .Operations }}

// {{ exportable $name }}Request generates a request for the {{ exportable $name }} operation.
func (c *{{ $.Name }}) {{ exportable $name }}Request({{ if $op.Input }}input {{ $op.Input.Type }}{{ end }}) (req *aws.Request{{ if $op.Output }}, output {{ structName $op.Output.Type }}{{ end }}) {
    if op{{ exportable $name }} == nil {
      op{{ exportable $name }} = &aws.Operation{
        Name:       "{{ $name }}",
        HTTPMethod: "{{ $op.HTTP.Method }}",
        HTTPPath:   "{{ $op.HTTP.RequestURI }}",
        {{ if eq $.Metadata.Protocol "rest-xml" "rest-json" }}
        OperationBindings: &aws.OperationBindings{
          {{ if $op.Input }}  InPayload:   "{{ $op.Input.Payload }}", {{ end }}
          {{ if $op.Output }} OutPayload:  "{{ $op.Output.Payload }}", {{ end }}
          Required:    []string{ {{ requiredTraits $op.Input }} },
          QueryParams: []string{ {{ locationTraits "query" $op.Input }} },
          URIParams:   []string{ {{ locationTraits "uri" $op.Input }} },
          InHeaders:   []string{ {{ locationTraits "header" $op.Input }} },
          OutHeaders:  []string{ {{ locationTraits "header" $op.Output }} },
        }, {{ else if hasRequiredTrait $op.Input }}
        OperationBindings: &aws.OperationBindings{
          Required:    []string{ {{ requiredTraits $op.Input }} },
        }, {{ end }}
      }
    }

    req = aws.NewRequest(c.Service, op{{ exportable $name }}, {{ if $op.Input }}input{{ else }}nil{{ end }}, {{ if $op.Output }}output{{ else }}nil{{ end }})
    {{ if $op.Output }}output = {{ structName $op.Output.Literal }}
    req.Data = output{{ end }}
    return
}

{{ godoc $name $op.Documentation }} func (c *{{ $.Name }}) {{ exportable $name }}({{ if $op.Input }}input {{ $op.Input.Type }}{{ end }}) ({{ if $op.Output }}output {{ structName $op.Output.Type }},{{ end }} err error) {
  req{{ if $op.Output }}, out{{ end }} := c.{{ exportable $name }}Request({{ if $op.Input }}input{{ end }})
  {{ if $op.Output }}output = out
  {{ end }}err = req.Send()
  return
}

{{ end }}

var (
{{ range $name, $op := .Operations }}op{{ exportable $name }} *aws.Operation
{{ end }}
)

{{ end }}
`)
}

func tplAPIShapes(t *template.Template) (*template.Template, error) {
	return t.Parse(`
{{ define "api-shapes" }}

{{ range $_, $s := enumList }}
// Possible values for {{ exportable $s.Alias }}.
const (
    {{ range $name, $value := $s.Shape.Enums }}
    {{ $name }} = {{ $value }}{{ end }}
)
{{ end }}

{{ range $_, $s := shapeList }}
{{ if eq $s.Shape.ShapeType "structure" }}

// {{ $s.Alias }} is undocumented.
type {{ $s.Alias }} struct {
{{ range $name, $m := $s.Shape.Members }}
{{ exportable $name }} {{ $m.Shape.Type }} {{ $m.Tag $.Metadata.Protocol $name }}  {{ end }}
}

{{ end }}
{{ end }}

{{ end }}
`)
}
