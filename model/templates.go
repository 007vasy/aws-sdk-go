package model

import (
	"bytes"
	"go/format"
	"io"
	"os"
	"path"
	"text/template"
)

// Generate writes a Go file with a client for using the parsed service.
func Generate(prefix string) error {
	apiFile := path.Join(prefix, service.PackageName, "api.go")
	apiWriter, err := os.Create(apiFile)
	if err != nil {
		panic(err)
	}
	defer apiWriter.Close()

	var svcWriter io.WriteCloser
	svcFile := path.Join(prefix, service.PackageName, "service.go")
	if _, err := os.Stat(svcFile); err != nil && os.IsNotExist(err) {
		svcWriter, err = os.Create(svcFile)
		if err != nil {
			panic(err)
		}
		defer svcWriter.Close()
	}

	return generateSource(apiWriter, svcWriter)
}

func generateSource(api io.Writer, svc io.Writer) error {
	t := template.New("root").Funcs(template.FuncMap{
		"godoc":            godoc,
		"exportable":       exportable,
		"structName":       structName,
		"enumList":         enumList,
		"shapeList":        shapeList,
		"shapeAlias":       shapeAlias,
		"protocolPackage":  protocolPackage,
		"requiredTraits":   requiredTraits,
		"locationTraits":   locationTraits,
		"hasRequiredTrait": hasRequiredTrait,
	})
	template.Must(commonAPI(t))
	template.Must(jsonClient(t))
	template.Must(queryClient(t))
	template.Must(ec2Client(t))
	template.Must(restXMLClient(t))
	template.Must(restJSONClient(t))

	if api != nil {
		apiOut := new(bytes.Buffer)
		if err := t.ExecuteTemplate(apiOut, service.Metadata.Protocol, service); err != nil {
			return err
		}
		apiFormatted, err := format.Source(apiOut.Bytes())
		if err != nil {
			return err
		}
		_, err = api.Write(apiFormatted)
		if err != nil {
			_, _ = api.Write(apiOut.Bytes())
			return err
		}
	}

	if svc != nil {
		svcOut := new(bytes.Buffer)
		if err := t.ExecuteTemplate(svcOut, "service", service); err != nil {
			return err
		}

		svcFormatted, err := format.Source(svcOut.Bytes())
		if err != nil {
			return err
		}

		_, err = svc.Write(svcFormatted)
		if err != nil {
			_, _ = svc.Write(svcOut.Bytes())
			return err
		}
	}

	return nil
}

func commonAPI(t *template.Template) (*template.Template, error) {
	return t.Parse(`
{{ define "service" }}
package {{ .PackageName }}

import (
    "github.com/awslabs/aws-sdk-go/aws"
    "github.com/awslabs/aws-sdk-go/aws/signer/v4"
    "github.com/awslabs/aws-sdk-go/aws/protocol/{{ protocolPackage $.Metadata.Protocol }}"
)

// {{ .Name }} is a client for {{ .FullName }}.
type {{ .Name }} struct {
    *aws.Service
}

type {{ .Name }}Config struct {
    *aws.Config
}

// New returns a new {{ .Name }} client.
func New(config *{{ .Name }}Config) *{{ .Name }} {
  if config == nil {
    config = &{{ .Name }}Config{}
  }

  service := &aws.Service{
    Config:       aws.DefaultConfig.Merge(config.Config),
    ServiceName:  "{{ .Metadata.EndpointPrefix }}",
    APIVersion:   "{{ .Metadata.APIVersion }}",
{{ if $.Metadata.Protocol eq "json" }}JSONVersion:  "{{ .Metadata.JSONVersion }}",
    TargetPrefix: "{{ .Metadata.TargetPrefix }}",
{{ end }}
  }
  service.Initialize()

  // Handlers
  service.Handlers.Sign.PushBack(v4.Sign)
  service.Handlers.Build.PushBack({{ protocolPackage $.Metadata.Protocol }}.Build)
  service.Handlers.Unmarshal.PushBack({{ protocolPackage $.Metadata.Protocol }}.Unmarshal)

  return &{{ .Name }}{service}
}
{{ end }}

{{ define "header" }}
////////////////////////////////////////////////////////
// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. //
////////////////////////////////////////////////////////

{{ godoc .Name .Documentation }} package {{ .PackageName }}

import (
  "time"

  "github.com/awslabs/aws-sdk-go/aws"
)

{{ end }}

{{ define "footer" }}
// avoid errors if the packages aren't referenced
var _ time.Time
{{ end }}

{{ define "operations" }}

{{ range $name, $op := .Operations }}

// {{ exportable $name }}Request generates a request for the {{ exportable $name }} operation.
func (c *{{ $.Name }}) {{ exportable $name }}Request({{ if $op.Input }}input {{ $op.Input.Type }}{{ end }}) (req *aws.Request{{ if $op.Output }}, output {{ structName $op.Output.Type }}{{ end }}) {
    if op{{ exportable $name }} == nil {
      op{{ exportable $name }} = &aws.Operation{
        Name:       "{{ $name }}",
        HTTPMethod: "{{ $op.HTTP.Method }}",
        HTTPPath:   "{{ $op.HTTP.RequestURI }}",
        {{ if eq $.Metadata.Protocol "rest-xml" "rest-json" }}
        OperationBindings: &aws.OperationBindings{
          {{ if $op.Input }}  InPayload:   "{{ $op.Input.Payload }}", {{ end }}
          {{ if $op.Output }} OutPayload:  "{{ $op.Output.Payload }}", {{ end }}
          Required:    []string{ {{ requiredTraits $op.Input }} },
          QueryParams: []string{ {{ locationTraits "query" $op.Input }} },
          URIParams:   []string{ {{ locationTraits "uri" $op.Input }} },
          InHeaders:   []string{ {{ locationTraits "header" $op.Input }} },
          OutHeaders:  []string{ {{ locationTraits "header" $op.Output }} },
        }, {{ else if hasRequiredTrait $op.Input }}
        OperationBindings: &aws.OperationBindings{
          Required:    []string{ {{ requiredTraits $op.Input }} },
        }, {{ end }}
      }
    }

    req = aws.NewRequest(c.Service, op{{ exportable $name }}, {{ if $op.Input }}input{{ else }}nil{{ end }}, {{ if $op.Output }}output{{ else }}nil{{ end }})
    {{ if $op.Output }}output = {{ structName $op.Output.Literal }}
    req.Data = output{{ end }}
    return
}

{{ godoc $name $op.Documentation }} func (c *{{ $.Name }}) {{ exportable $name }}({{ if $op.Input }}input {{ $op.Input.Type }}{{ end }}) ({{ if $op.Output }}output {{ structName $op.Output.Type }},{{ end }} err error) {
  req{{ if $op.Output }}, out{{ end }} := c.{{ exportable $name }}Request({{ if $op.Input }}input{{ end }})
  {{ if $op.Output }}output = out
  {{ end }}err = req.Send()
  return
}

{{ end }}

var (
{{ range $name, $op := .Operations }}op{{ exportable $name }} *aws.Operation
{{ end }}
)

{{ range $_, $s := enumList }}
// Possible values for {{ exportable $s.Alias }}.
const (
    {{ range $name, $value := $s.Shape.Enums }}
    {{ $name }} = {{ $value }}{{ end }}
)
{{ end }}

{{ end }}
`)
}

func jsonClient(t *template.Template) (*template.Template, error) {
	return t.Parse(`
{{ define "json" }}
{{ template "header" $ }}
{{ template "operations" $ }}

{{ range $_, $s := shapeList }}
{{ if eq $s.Shape.ShapeType "structure" }}

// {{ $s.Alias }} is undocumented.
type {{ $s.Alias }} struct {
{{ range $name, $m := $s.Shape.Members }}
{{ exportable $name }} {{ $m.Shape.Type }} {{ $m.JSONTag }}  {{ end }}
}

{{ end }}
{{ end }}

{{ template "footer" }}
{{ end }}

`)
}

func queryClient(t *template.Template) (*template.Template, error) {
	return t.Parse(`
{{ define "query" }}
{{ template "header" $ }}

import (
	"io"
	"encoding/xml"
)

{{ template "operations" $ }}

{{ range $name, $s := .Shapes }}
{{ if eq $s.ShapeType "map" }}

type {{ exportable $name }} map[{{ $s.Key.ElementType }}]{{ $s.Value.ElementType }}

// UnmarshalXML implements xml.UnmarshalXML interface for map
func (m *{{ exportable $name }}) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	if *m == nil {
		(*m) = make({{ exportable $name }})
	}
	for {
		var e struct {
			{{ or $s.KeyRef.LocationName "Key" }} {{ $s.Key.ElementType }} {{ $s.KeyXMLTag }}
			{{ or $s.ValueRef.LocationName "Value" }} {{ $s.Value.ElementType }} {{ $s.ValueXMLTag }}
		}
		err := d.DecodeElement(&e, &start)
		if err != nil && err != io.EOF {
			return err
		}
		if err == io.EOF {
			break
		}
		(*m)[e.{{ or $s.KeyRef.LocationName "Key" }}] = e.{{ or $s.ValueRef.LocationName "Value" }}
	}
	return nil
}
{{ end }}

{{ if eq $s.ShapeType "structure" }}

// {{ exportable $name }} is undocumented.
type {{ structName $name }} struct {
{{ range $name, $m := $s.Members }}
{{ exportable $name }} {{ $m.Type }} {{ $m.QueryTag $s.ResultWrapper }}  {{ end }}
}

{{ end }}
{{ end }}

{{ range $wname, $s := .Wrappers }}

// {{ exportable $wname }} is a wrapper for {{ $s.Name }}.
type {{ exportable $wname }} struct {
{{ range $name, $m := $s.Members }}
{{ exportable $name }} {{ $m.Type }} {{ $m.QueryTag $wname }}  {{ end }}
}

{{ end }}

{{ template "footer" }}
var _ xml.Decoder
var _ = io.EOF
{{ end }}

`)
}

func ec2Client(t *template.Template) (*template.Template, error) {
	return t.Parse(`
{{ define "ec2" }}
{{ template "header" $ }}

// {{ .Name }} is a client for {{ .FullName }}.
type {{ .Name }} struct {
  client *aws.EC2Client
}

// New returns a new {{ .Name }} client.
func New(creds aws.CredentialsProvider, region string, client *http.Client) *{{ .Name }} {
  if client == nil {
     client = http.DefaultClient
  }

  endpoint, service, region := endpoints.Lookup("{{ .Metadata.EndpointPrefix }}", region)

  return &{{ .Name }}{
    client: &aws.EC2Client{
      Context: aws.Context{
        Credentials: creds,
        Service: service,
        Region: region,
      },
      Client: client,
      Endpoint: endpoint,
      APIVersion: "{{ .Metadata.APIVersion }}",
    },
  }
}

{{ range $name, $op := .Operations }}

{{ godoc $name $op.Documentation }} func (c *{{ $.Name }}) {{ exportable $name }}({{ if $op.InputRef }}req {{ $op.InputRef.WrappedType }}{{ end }}) ({{ if $op.OutputRef }}resp {{ $op.OutputRef.WrappedType }},{{ end }} err error) {
  {{ if $op.Output }}resp = {{ $op.OutputRef.WrappedLiteral }}{{ else }}// NRE{{ end }}
  err = c.client.Do("{{ $name }}", "{{ $op.HTTP.Method }}", "{{ $op.HTTP.RequestURI }}", {{ if $op.Input }} req {{ else }} nil {{ end }}, {{ if $op.Output }} resp {{ else }} nil {{ end }})
  return
}

{{ end }}

{{ range $name, $s := .Shapes }}
{{ if eq $s.ShapeType "structure" }}

// {{ exportable $name }} is undocumented.
type {{ exportable $name }} struct {
{{ range $name, $m := $s.Members }}
{{ exportable $name }} {{ $m.Type }} {{ $m.EC2Tag }}  {{ end }}
}

{{ end }}
{{ end }}

{{ range $wname, $s := .Wrappers }}

// {{ exportable $wname }} is a wrapper for {{ $s.Name }}.
type {{ exportable $wname }} struct {
{{ range $name, $m := $s.Members }}
{{ exportable $name }} {{ $m.Type }} {{ $m.EC2Tag }}  {{ end }}
}

{{ end }}

{{ template "footer" }}
{{ end }}

`)
}

func restXMLClient(t *template.Template) (*template.Template, error) {
	return t.Parse(`
{{ define "rest-xml" }}
{{ template "header" $ }}

import (
  "encoding/xml"
  "io"
)

{{ template "operations" $ }}

{{ range $_, $s := shapeList }}
{{ if eq $s.Shape.ShapeType "structure" }}

// {{ $s.Alias }} is undocumented.
type {{ $s.Alias }} struct {
  XMLName xml.Name
{{ range $name, $m := $s.Shape.Members }}
{{ exportable $name }} {{ $m.Type }} {{ $m.XMLTag $s.Shape.ResultWrapper }}  {{ end }}
}

func (v *{{ $s.Alias }}) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

{{ end }}
{{ end }}

{{ template "footer" }}
var _ io.Reader
{{ end }}

`)
}

func restJSONClient(t *template.Template) (*template.Template, error) {
	return t.Parse(`
{{ define "rest-json" }}
{{ template "header" $ }}
{{ template "operations" $ }}

{{ range $_, $s := shapeList }}
{{ if eq $s.Shape.ShapeType "structure" }}

// {{ $s.Alias }} is undocumented.
type {{ $s.Alias }} struct {
{{ range $name, $m := $s.Shape.Members }}
{{ exportable $name }} {{ $m.Type }} {{ $m.JSONTag }}  {{ end }}
}

{{ end }}
{{ end }}

{{ template "footer" }}
{{ end }}
`)
}
